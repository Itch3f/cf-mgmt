// This file was generated by counterfeiter
package fakes

import (
	"sync"

	go_cfclient "github.com/cloudfoundry-community/go-cfclient"
	"github.com/pivotalservices/cf-mgmt/space"
)

type FakeManager struct {
	FindSpaceStub        func(orgName, spaceName string) (go_cfclient.Space, error)
	findSpaceMutex       sync.RWMutex
	findSpaceArgsForCall []struct {
		orgName   string
		spaceName string
	}
	findSpaceReturns struct {
		result1 go_cfclient.Space
		result2 error
	}
	CreateSpacesStub        func(configDir, ldapBindPassword string) error
	createSpacesMutex       sync.RWMutex
	createSpacesArgsForCall []struct {
		configDir        string
		ldapBindPassword string
	}
	createSpacesReturns struct {
		result1 error
	}
	UpdateSpacesStub        func(configDir string) (err error)
	updateSpacesMutex       sync.RWMutex
	updateSpacesArgsForCall []struct {
		configDir string
	}
	updateSpacesReturns struct {
		result1 error
	}
	DeleteSpacesStub        func(configFile string) (err error)
	deleteSpacesMutex       sync.RWMutex
	deleteSpacesArgsForCall []struct {
		configFile string
	}
	deleteSpacesReturns struct {
		result1 error
	}
	ListSpacesStub        func(orgGUID string) ([]go_cfclient.Space, error)
	listSpacesMutex       sync.RWMutex
	listSpacesArgsForCall []struct {
		orgGUID string
	}
	listSpacesReturns struct {
		result1 []go_cfclient.Space
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeManager) FindSpace(orgName string, spaceName string) (go_cfclient.Space, error) {
	fake.findSpaceMutex.Lock()
	fake.findSpaceArgsForCall = append(fake.findSpaceArgsForCall, struct {
		orgName   string
		spaceName string
	}{orgName, spaceName})
	fake.recordInvocation("FindSpace", []interface{}{orgName, spaceName})
	fake.findSpaceMutex.Unlock()
	if fake.FindSpaceStub != nil {
		return fake.FindSpaceStub(orgName, spaceName)
	} else {
		return fake.findSpaceReturns.result1, fake.findSpaceReturns.result2
	}
}

func (fake *FakeManager) FindSpaceCallCount() int {
	fake.findSpaceMutex.RLock()
	defer fake.findSpaceMutex.RUnlock()
	return len(fake.findSpaceArgsForCall)
}

func (fake *FakeManager) FindSpaceArgsForCall(i int) (string, string) {
	fake.findSpaceMutex.RLock()
	defer fake.findSpaceMutex.RUnlock()
	return fake.findSpaceArgsForCall[i].orgName, fake.findSpaceArgsForCall[i].spaceName
}

func (fake *FakeManager) FindSpaceReturns(result1 go_cfclient.Space, result2 error) {
	fake.FindSpaceStub = nil
	fake.findSpaceReturns = struct {
		result1 go_cfclient.Space
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) CreateSpaces(configDir string, ldapBindPassword string) error {
	fake.createSpacesMutex.Lock()
	fake.createSpacesArgsForCall = append(fake.createSpacesArgsForCall, struct {
		configDir        string
		ldapBindPassword string
	}{configDir, ldapBindPassword})
	fake.recordInvocation("CreateSpaces", []interface{}{configDir, ldapBindPassword})
	fake.createSpacesMutex.Unlock()
	if fake.CreateSpacesStub != nil {
		return fake.CreateSpacesStub(configDir, ldapBindPassword)
	} else {
		return fake.createSpacesReturns.result1
	}
}

func (fake *FakeManager) CreateSpacesCallCount() int {
	fake.createSpacesMutex.RLock()
	defer fake.createSpacesMutex.RUnlock()
	return len(fake.createSpacesArgsForCall)
}

func (fake *FakeManager) CreateSpacesArgsForCall(i int) (string, string) {
	fake.createSpacesMutex.RLock()
	defer fake.createSpacesMutex.RUnlock()
	return fake.createSpacesArgsForCall[i].configDir, fake.createSpacesArgsForCall[i].ldapBindPassword
}

func (fake *FakeManager) CreateSpacesReturns(result1 error) {
	fake.CreateSpacesStub = nil
	fake.createSpacesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) UpdateSpaces(configDir string) (err error) {
	fake.updateSpacesMutex.Lock()
	fake.updateSpacesArgsForCall = append(fake.updateSpacesArgsForCall, struct {
		configDir string
	}{configDir})
	fake.recordInvocation("UpdateSpaces", []interface{}{configDir})
	fake.updateSpacesMutex.Unlock()
	if fake.UpdateSpacesStub != nil {
		return fake.UpdateSpacesStub(configDir)
	} else {
		return fake.updateSpacesReturns.result1
	}
}

func (fake *FakeManager) UpdateSpacesCallCount() int {
	fake.updateSpacesMutex.RLock()
	defer fake.updateSpacesMutex.RUnlock()
	return len(fake.updateSpacesArgsForCall)
}

func (fake *FakeManager) UpdateSpacesArgsForCall(i int) string {
	fake.updateSpacesMutex.RLock()
	defer fake.updateSpacesMutex.RUnlock()
	return fake.updateSpacesArgsForCall[i].configDir
}

func (fake *FakeManager) UpdateSpacesReturns(result1 error) {
	fake.UpdateSpacesStub = nil
	fake.updateSpacesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) DeleteSpaces(configFile string) (err error) {
	fake.deleteSpacesMutex.Lock()
	fake.deleteSpacesArgsForCall = append(fake.deleteSpacesArgsForCall, struct {
		configFile string
	}{configFile})
	fake.recordInvocation("DeleteSpaces", []interface{}{configFile})
	fake.deleteSpacesMutex.Unlock()
	if fake.DeleteSpacesStub != nil {
		return fake.DeleteSpacesStub(configFile)
	} else {
		return fake.deleteSpacesReturns.result1
	}
}

func (fake *FakeManager) DeleteSpacesCallCount() int {
	fake.deleteSpacesMutex.RLock()
	defer fake.deleteSpacesMutex.RUnlock()
	return len(fake.deleteSpacesArgsForCall)
}

func (fake *FakeManager) DeleteSpacesArgsForCall(i int) string {
	fake.deleteSpacesMutex.RLock()
	defer fake.deleteSpacesMutex.RUnlock()
	return fake.deleteSpacesArgsForCall[i].configFile
}

func (fake *FakeManager) DeleteSpacesReturns(result1 error) {
	fake.DeleteSpacesStub = nil
	fake.deleteSpacesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) ListSpaces(orgGUID string) ([]go_cfclient.Space, error) {
	fake.listSpacesMutex.Lock()
	fake.listSpacesArgsForCall = append(fake.listSpacesArgsForCall, struct {
		orgGUID string
	}{orgGUID})
	fake.recordInvocation("ListSpaces", []interface{}{orgGUID})
	fake.listSpacesMutex.Unlock()
	if fake.ListSpacesStub != nil {
		return fake.ListSpacesStub(orgGUID)
	} else {
		return fake.listSpacesReturns.result1, fake.listSpacesReturns.result2
	}
}

func (fake *FakeManager) ListSpacesCallCount() int {
	fake.listSpacesMutex.RLock()
	defer fake.listSpacesMutex.RUnlock()
	return len(fake.listSpacesArgsForCall)
}

func (fake *FakeManager) ListSpacesArgsForCall(i int) string {
	fake.listSpacesMutex.RLock()
	defer fake.listSpacesMutex.RUnlock()
	return fake.listSpacesArgsForCall[i].orgGUID
}

func (fake *FakeManager) ListSpacesReturns(result1 []go_cfclient.Space, result2 error) {
	fake.ListSpacesStub = nil
	fake.listSpacesReturns = struct {
		result1 []go_cfclient.Space
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.findSpaceMutex.RLock()
	defer fake.findSpaceMutex.RUnlock()
	fake.createSpacesMutex.RLock()
	defer fake.createSpacesMutex.RUnlock()
	fake.updateSpacesMutex.RLock()
	defer fake.updateSpacesMutex.RUnlock()
	fake.deleteSpacesMutex.RLock()
	defer fake.deleteSpacesMutex.RUnlock()
	fake.listSpacesMutex.RLock()
	defer fake.listSpacesMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ space.Manager = new(FakeManager)
